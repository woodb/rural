#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
rural
~~~~~
Simple command line utility for uploading local files to Amazon Web Services
(AWS) Simple Storage Service (S3).
"""

CONFIG_MISSING_MESSAGE = """rural has not yet been configured, or the configuration 
file appears to be missing. Run the configuration wizard with `rural --configure`
"""

def _create_config(fh):
    """
    rural._create_config
    ~~~~~~~~~~~~~~~~~~~~
    Prompts to create the configuration file.
    """
    sys.stdout.write("AWS Access Key ID: ")
    aws_access_key = raw_input().upper()

    sys.stdout.write("   AWS Secret Key: ")
    aws_secret_key = raw_input()

    sys.stdout.write("   Default Bucket: ")
    default_bucket_name = raw_input()

    fh.write(yaml.dump({'aws_access_key' : aws_access_key,
               'aws_secret_key' : aws_secret_key,
               'bucket_name'    : default_bucket_name},
               Dumper=Dumper))


def _load_config(fh):
    cfg_data = yaml.load(fh)
    return cfg_data['aws_access_key'], cfg_data['aws_secret_key'], \
        cfg_data['bucket_name']


def _cb_progressbar(uploaded_bytes, total_bytes):
    """Callback function that outputs a progressbar to stderr based on what's
    up"""
    import sys

    pbw = 80 # progress bar width 

    progress_percent = float(uploaded_bytes) / float(total_bytes)

    sys.stderr.write("\r[%s%s] %d%%" % (
        '=' * int(progress_percent * pbw / 2),
        ' ' * (pbw / 2- int(progress_percent * pbw / 2)),
        int(progress_percent * 100)))

    if progress_percent == 1:
        sys.stderr.write("\n")


def _main():
    """
    rural._main
    ~~~~~~~~~~~
    Handles option parsing, configuration management and command execution.
    """
    # Parse command line arguments
    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("filename", help="name of file to upload", nargs='?',
            default=None)
    parser.add_argument("--configure", dest="configure", action="store_true")
    args = parser.parse_args()
    if args.filename:
        filename = args.filename
    else:
        raise IOError("filename must be defined at runtime")

    
    # Configuration
    # ~~~~~~~~~~~~~
    config_file = None
    if os.getenv("HOME"):
        config_file = os.path.join(os.getenv("HOME"), ".rural")
    else:
        raise NotImplementedError, "rural currently only supports POSIX \
            compliant environments (i.e. rural does not work on Windows)"
        sys.exit(1)

    try:
        config_fh = open(config_file, "r")
    except IOError:
        if not args.configure:
            print CONFIG_MISSING_MESSAGE
            sys.exit(1)

    if args.configure:
        config_fh = open(config_file, 'w')
        _create_config(config_fh)
        sys.exit(0)


    # Amazon Web Services (AWS) Related Logic
    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    aws_access_key, aws_secret_key, bucket_name = _load_config(config_fh)
    if bucket_name and aws_access_key and aws_secret_key:
        from boto.s3.connection import S3Connection
        from boto.s3.key import Key
        from boto.s3.bucket import Bucket
        s3conn = S3Connection(aws_access_key_id=aws_access_key,
                    aws_secret_access_key=aws_secret_key)
        bucket = Bucket(s3conn, bucket_name)

        # Upload file to S3
        k = Key(bucket)
        k.key = filename
        k.set_contents_from_filename(filename, cb=_cb_progressbar)
        k.make_public()

        # Get the AWS S3 public URL for the uploaded file
        url = k.generate_url(86400)
        url = ''.join(url.split('?')[:-1])

        # Print AWS S3 public URL to the clipboard and stdout
        from xerox import copy
        copy(url)
        print url
    else:
        raise ValueError, "AWS configuration incomplete"
        sys.exit(1)


if __name__ == '__main__':
    import os
    import sys

    import yaml
    try:
        from yaml import CLoader as Loader, CDumper as Dumper
    except ImportError:
        from yaml import Loader, Dumper
    except Exception as exc:
        raise exc
        sys.exit(1)

    _main()
